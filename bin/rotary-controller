#!/usr/bin/env python3
"""Rotary switch controller for radio-voice project.

Reads BCD rotary switches for bank/station selection and a single
encoder for volume control. No display output.
"""
import time
from pathlib import Path
from typing import Dict, Optional

import board
import busio
from adafruit_seesaw.seesaw import Seesaw
from adafruit_seesaw.rotaryio import IncrementalEncoder
from mpd import MPDClient
import RPi.GPIO as GPIO

from radio_lib import (
    setup_logging,
    parse_i2c_addr,
    load_yaml,
    read_state,
    write_state,
    sh,
    clamp,
    wait_for_mpd,
    validate_hardware_config
)

# Configuration paths
CFG_PATH = Path("/home/radio/hardware-rotary.yaml")
STATE_PATH = Path("/home/radio/.radio-state")
STATIONS_PATH = Path("/home/radio/stations.yaml")

# Hardware configuration
SEESAW_BUTTON_PIN = 24  # Seesaw GPIO for volume encoder button
PLAY_PAUSE_SWITCH_PIN = 24  # BCM GPIO pin for external play/pause on/off switch
MAX_JUMP = 8    # Max encoder delta per poll (glitch filter)
I2C_ERR_BACKOFF = 0.2  # Seconds to wait after I2C error

# Playback watchdog: auto-resume streams that stop unexpectedly.
# After detecting MPD in "stop" state, wait WATCHDOG_GRACE_SEC before
# restarting so we don't fight intentional pauses or brief interruptions.
# On repeated failures the delay grows exponentially up to the max.
WATCHDOG_GRACE_SEC = 10.0
WATCHDOG_CHECK_INTERVAL = 5.0  # How often to poll MPD state for watchdog
WATCHDOG_BACKOFF_MAX = 320.0   # Cap on exponential backoff (seconds)

# Station types that represent infinite streams (should never end on their
# own).  Local-file types like "file" or "dir" can legitimately finish.
_STREAM_TYPES = frozenset({
    "stream",
})

# Setup logging
logger = setup_logging('rotary-controller', Path('/home/radio/logs/rotary.log'))


def decode_switch(
    raw: int,
    last_valid: int,
    code_map: Optional[Dict[int, int]] = None,
    min_v: int = 0,
    max_v: int = 9,
) -> int:
    """Decode a raw 4-bit switch value into a digit, holding last valid on invalid input."""
    if code_map is not None:
        decoded = code_map.get(raw, last_valid)
        if min_v <= decoded <= max_v:
            return decoded
        return last_valid
    if min_v <= raw <= max_v:
        return raw
    return last_valid


def normalize_code_map(raw_map: object, name: str) -> Dict[int, int]:
    """Normalize YAML decode map values to int->int mapping."""
    if not isinstance(raw_map, dict):
        raise ValueError(f"{name} must be a mapping")

    normalized = {}
    for raw_code, decoded in raw_map.items():
        try:
            raw_int = int(raw_code)
            decoded_int = int(decoded)
        except (TypeError, ValueError) as err:
            raise ValueError(f"{name} contains non-integer key/value ({raw_code!r}:{decoded!r})") from err
        normalized[raw_int] = decoded_int
    return normalized


def build_decode_map(raw_map: object, name: str) -> Dict[int, int]:
    """Build switch decode map with sensible defaults and optional overrides.

    Defaults map raw BCD 0-9 directly to logical 0-9. If the override map
    includes any entry decoding to 9, default 9-mappings are removed first so
    configs can remap digit 9 (for example 12 -> 9).
    """
    decode_map = {code: code for code in range(10)}
    if raw_map is None:
        return decode_map

    overrides = normalize_code_map(raw_map, name)

    if any(decoded == 9 for decoded in overrides.values()):
        decode_map = {
            raw_code: decoded
            for raw_code, decoded in decode_map.items()
            if decoded != 9
        }

    decode_map.update(overrides)
    return decode_map


class MpdConnection:
    """Persistent MPD client wrapper with automatic reconnect."""

    def __init__(self, logger, host: str = "localhost", port: int = 6600, timeout: int = 5):
        self.logger = logger
        self.host = host
        self.port = port
        self.timeout = timeout
        self.client = self._new_client()
        self.connected = False

    def _new_client(self) -> MPDClient:
        client = MPDClient()
        client.timeout = self.timeout
        client.idletimeout = None
        return client

    def _ensure_connected(self) -> None:
        if self.connected:
            return
        self.client.connect(self.host, self.port)
        self.connected = True

    def _reconnect(self) -> None:
        try:
            if self.connected:
                self.client.disconnect()
        except Exception:
            pass
        self.client = self._new_client()
        self.connected = False
        self._ensure_connected()

    def command(self, name: str, *args):
        for attempt in range(2):
            try:
                if attempt == 0:
                    self._ensure_connected()
                else:
                    self._reconnect()
                return getattr(self.client, name)(*args)
            except Exception as err:
                self.connected = False
                if attempt == 1:
                    raise
                self.logger.warning(f"MPD command '{name}' failed ({err}), reconnecting")

    def status(self) -> dict:
        return self.command("status")

    def setvol(self, volume: int) -> None:
        self.command("setvol", int(volume))

    def toggle(self) -> None:
        self.command("pause")

    def play(self) -> None:
        self.command("play")

    def pause(self) -> None:
        self.command("pause", 1)


def read_bcd_switch(pins: dict) -> int:
    """Read a 4-bit BCD value from GPIO pins.
    
    Args:
        pins: Dict with keys bit0, bit1, bit2, bit3 (GPIO pin numbers)
        
    Returns:
        Integer 0-15 (though switches only use 0-9)
    """
    bit0 = GPIO.input(pins['bit0'])
    bit1 = GPIO.input(pins['bit1'])
    bit2 = GPIO.input(pins['bit2'])
    bit3 = GPIO.input(pins['bit3'])
    
    # Convert binary to decimal
    # Active LOW: if pin reads 0, bit is SET
    value = 0
    if bit0 == GPIO.LOW:
        value += 1
    if bit1 == GPIO.LOW:
        value += 2
    if bit2 == GPIO.LOW:
        value += 4
    if bit3 == GPIO.LOW:
        value += 8
    
    return value


def stations_exist(bank: int, station: int) -> bool:
    """Check if a bank/station combination exists in stations.yaml."""
    data = load_yaml(STATIONS_PATH)
    banks = data.get("banks", {})
    b = banks.get(bank)
    if not isinstance(b, dict):
        return False
    s = b.get("stations", {})
    return isinstance(s, dict) and station in s


class StationsCache:
    """Cache stations.yaml and reload only when file mtime changes."""

    def __init__(self, path: Path):
        self.path = path
        self._mtime = None
        self._data = {}

    def _reload_if_needed(self) -> None:
        try:
            mtime = self.path.stat().st_mtime
        except FileNotFoundError:
            # Keep empty cache if stations file disappears.
            self._mtime = None
            self._data = {}
            return

        if self._mtime != mtime:
            self._data = load_yaml(self.path)
            self._mtime = mtime

    def station_exists(self, bank: int, station: int) -> bool:
        self._reload_if_needed()

        banks = self._data.get("banks", {})
        b = banks.get(bank)
        if not isinstance(b, dict):
            return False

        s = b.get("stations", {})
        return isinstance(s, dict) and station in s

    def station_type(self, bank: int, station: int) -> Optional[str]:
        """Return the station type (e.g. 'stream', 'file_loop') or None."""
        self._reload_if_needed()
        banks = self._data.get("banks", {})
        b = banks.get(bank)
        if not isinstance(b, dict):
            return None
        s = b.get("stations", {})
        entry = s.get(station) if isinstance(s, dict) else None
        if not isinstance(entry, dict):
            return None
        return (entry.get("type") or "").strip() or None


def main():
    """Main rotary controller loop."""
    logger.info("=" * 50)
    logger.info("Rotary Switch Controller Starting")
    logger.info("=" * 50)
    
    # Load and validate configuration
    if not CFG_PATH.exists():
        logger.error(f"Configuration file not found: {CFG_PATH}")
        raise SystemExit(1)
    
    cfg = load_yaml(CFG_PATH)

    validation_errors = validate_hardware_config(cfg, variant="rotary")
    if validation_errors:
        logger.error("Invalid configuration. Please fix /home/radio/hardware-rotary.yaml:")
        for err in validation_errors:
            logger.error(f"  - {err}")
        raise SystemExit(1)

    # Extract configuration
    i2c_cfg = cfg.get("i2c", {})
    switch_cfg = cfg.get("switches", {})
    enc_cfg = cfg.get("encoders", {})
    ctl = cfg.get("controls", {})
    btn_cfg = cfg.get("buttons", {})
    poll_cfg = cfg.get("polling", {})
    
    addr = parse_i2c_addr(i2c_cfg.get("volume_i2c_address", "0x36"))
    logger.info(f"Volume encoder I2C address: 0x{addr:02x}")
    
    # GPIO pin mappings
    station_pins = switch_cfg.get("station_switch", {})
    bank_pins = switch_cfg.get("bank_switch", {})
    
    # Encoder indices
    vol_idx = int(enc_cfg.get("volume_encoder", 0))
    
    # Control ranges
    bank_min = int(ctl.get("bank_min", 0))
    bank_max = int(ctl.get("bank_max", 9))
    st_min = int(ctl.get("station_min", 0))
    st_max = int(ctl.get("station_max", 9))
    vmin = int(ctl.get("volume_min", 0))
    vmax = int(ctl.get("volume_max", 100))
    vstep = int(ctl.get("volume_step", 2))
    
    # Polling configuration
    poll_interval = float(poll_cfg.get("switch_poll_interval", 0.1))
    debounce_time = float(poll_cfg.get("switch_debounce", 0.05))
    stability_window = float(poll_cfg.get("switch_stability_window", 0.12))
    invalid_log_interval = float(poll_cfg.get("invalid_code_log_interval", 5.0))

    bank_decode_map = build_decode_map(
        switch_cfg.get("bank_decode_map"),
        "switches.bank_decode_map",
    )
    station_decode_map = build_decode_map(
        switch_cfg.get("station_decode_map"),
        "switches.station_decode_map",
    )
    bank_valid_raw_codes = set(bank_decode_map.keys())
    station_valid_raw_codes = set(station_decode_map.keys())
    
    logger.info(f"Bank range: {bank_min}-{bank_max}")
    logger.info(f"Station range: {st_min}-{st_max}")
    logger.info(f"Volume range: {vmin}-{vmax}, step: {vstep}")
    logger.info(
        f"Poll interval: {poll_interval}s, debounce: {debounce_time}s, "
        f"stability window: {stability_window}s"
    )
    logger.info(f"Bank decode map loaded with {len(bank_decode_map)} entries")
    logger.info(f"Station decode map loaded with {len(station_decode_map)} entries")
    
    # Wait for MPD to be ready
    if not wait_for_mpd(logger=logger):
        raise SystemExit("MPD not available")

    mpd_conn = MpdConnection(logger)
    
    # Setup GPIO
    logger.info("Initializing GPIO...")
    GPIO.setmode(GPIO.BCM)
    GPIO.setwarnings(False)
    
    # Configure all switch pins as inputs with pull-up resistors
    all_pins = [
        station_pins['bit0'], station_pins['bit1'], 
        station_pins['bit2'], station_pins['bit3'],
        bank_pins['bit0'], bank_pins['bit1'],
        bank_pins['bit2'], bank_pins['bit3'],
        PLAY_PAUSE_SWITCH_PIN,
    ]
    
    for pin in all_pins:
        GPIO.setup(pin, GPIO.IN, pull_up_down=GPIO.PUD_UP)
    
    logger.info(f"Station switch GPIOs: {station_pins}")
    logger.info(f"Bank switch GPIOs: {bank_pins}")
    logger.info(f"Play/pause switch GPIO: {PLAY_PAUSE_SWITCH_PIN}")
    
    # Initialize I2C and Seesaw for volume encoder
    logger.info("Initializing I2C for volume encoder...")
    try:
        i2c = busio.I2C(board.SCL, board.SDA)
        ss = Seesaw(i2c, addr=addr)
        logger.info("I2C initialized successfully")
    except Exception as e:
        logger.error(f"Failed to initialize I2C: {e}")
        raise SystemExit(1)
    
    # Configure volume encoder button
    ss.pin_mode(SEESAW_BUTTON_PIN, ss.INPUT_PULLUP)
    
    # Initialize volume encoder
    vol_enc = IncrementalEncoder(ss, vol_idx)
    last_vol_pos = vol_enc.position
    last_btn = ss.digital_read(SEESAW_BUTTON_PIN)
    play_enabled = GPIO.input(PLAY_PAUSE_SWITCH_PIN) == GPIO.HIGH
    
    # Load initial state
    st = read_state(STATE_PATH)
    last_volume = int(st.get("last_volume", "60"))
    
    # Track restart count
    restart_count = int(st.get("rotary_restarts", "0")) + 1
    
    # Read initial switch positions (invalid raw values keep last known-good state)
    persisted_bank = int(st.get("current_bank", str(bank_min)))
    persisted_station = int(st.get("current_station", str(st_min)))
    cur_bank = persisted_bank if bank_min <= persisted_bank <= bank_max else bank_min
    cur_station = persisted_station if st_min <= persisted_station <= st_max else st_min

    bank_raw = read_bcd_switch(bank_pins)
    station_raw = read_bcd_switch(station_pins)
    cur_bank = decode_switch(bank_raw, cur_bank, bank_decode_map, bank_min, bank_max)
    cur_station = decode_switch(station_raw, cur_station, station_decode_map, st_min, st_max)

    # Track last station we requested from radio-play.
    # Start from persisted state so switch bounce that settles back to the
    # already playing position does not trigger an unnecessary restart.
    playing_bank = int(st.get("current_bank", str(cur_bank)))
    playing_station = int(st.get("current_station", str(cur_station)))
    
    write_state(
        STATE_PATH,
        current_bank=cur_bank,
        current_station=cur_station,
        last_volume=last_volume,
        rotary_restarts=restart_count
    )
    
    logger.info(f"Initial state: Bank {cur_bank}, Station {cur_station}, Volume {last_volume}")
    logger.info(f"Initial play/pause switch state: {'ON (play)' if play_enabled else 'OFF (pause)'}")
    logger.info(f"Restart count: {restart_count}")

    # Enforce physical play/pause switch state immediately on startup.
    # This ensures OFF always pauses playback even after controller restarts.
    if not play_enabled:
        logger.info("Startup play/pause switch is OFF: pausing playback")
        mpd_conn.pause()
    
    # Track mute state
    muted = False
    
    # Debounce tracking
    last_switch_change = 0.0
    bank_candidate = cur_bank
    station_candidate = cur_station
    bank_candidate_since = 0.0
    station_candidate_since = 0.0
    last_invalid_bank_log = 0.0
    last_invalid_station_log = 0.0
    
    # Playback watchdog state
    watchdog_stop_since = 0.0      # monotonic time when we first saw "stop"
    watchdog_last_check = 0.0      # last time we queried MPD for watchdog
    watchdog_backoff = WATCHDOG_GRACE_SEC  # current grace period (grows on repeated failures)
    watchdog_last_restart = 0.0    # when we last issued a watchdog restart

    logger.info("Entering main loop")

    stations_cache = StationsCache(STATIONS_PATH)
    
    # Main event loop
    while True:
        try:
            # Read current switch positions
            bank_raw = read_bcd_switch(bank_pins)
            station_raw = read_bcd_switch(station_pins)
            bank = decode_switch(bank_raw, cur_bank, bank_decode_map, bank_min, bank_max)
            station = decode_switch(station_raw, cur_station, station_decode_map, st_min, st_max)

            now = time.monotonic()

            if bank == cur_bank and bank_raw not in bank_valid_raw_codes:
                if now - last_invalid_bank_log >= invalid_log_interval:
                    logger.warning(
                        f"Invalid BANK raw code ignored: raw={bank_raw}, keeping decoded={cur_bank}"
                    )
                    last_invalid_bank_log = now
            if station == cur_station and station_raw not in station_valid_raw_codes:
                if now - last_invalid_station_log >= invalid_log_interval:
                    logger.warning(
                        f"Invalid STATION raw code ignored: raw={station_raw}, keeping decoded={cur_station}"
                    )
                    last_invalid_station_log = now

            # Stability filter: require stable identical decoded value before acceptance.
            accepted_bank = cur_bank
            if bank != cur_bank:
                if bank != bank_candidate:
                    bank_candidate = bank
                    bank_candidate_since = now
                elif now - bank_candidate_since >= stability_window:
                    accepted_bank = bank
            else:
                bank_candidate = cur_bank
                bank_candidate_since = now

            accepted_station = cur_station
            if station != cur_station:
                if station != station_candidate:
                    station_candidate = station
                    station_candidate_since = now
                elif now - station_candidate_since >= stability_window:
                    accepted_station = station
            else:
                station_candidate = cur_station
                station_candidate_since = now
            
            # Check if switches changed (with debouncing)
            if (accepted_bank != cur_bank or accepted_station != cur_station):
                
                # Debounce: ignore rapid changes
                if now - last_switch_change < debounce_time:
                    time.sleep(debounce_time)
                    continue
                
                last_switch_change = now
                
                # Log the change
                if accepted_bank != cur_bank:
                    logger.info(
                        f"Bank switch changed: {cur_bank} → {accepted_bank} (raw={bank_raw})"
                    )
                if accepted_station != cur_station:
                    logger.info(
                        f"Station switch changed: {cur_station} → {accepted_station} (raw={station_raw})"
                    )
                
                cur_bank = accepted_bank
                cur_station = accepted_station
                
                # Save state
                write_state(STATE_PATH, current_bank=cur_bank, current_station=cur_station)
                
                # Play the new station immediately (no settle delay needed)
                # even if the play/pause switch is currently OFF.
                if stations_cache.station_exists(cur_bank, cur_station):
                    if cur_bank == playing_bank and cur_station == playing_station:
                        logger.info(
                            f"Already playing: Bank {cur_bank}, Station {cur_station} (skip restart)"
                        )
                    else:
                        if not play_enabled:
                            logger.info(
                                f"Selected Bank {cur_bank}, Station {cur_station} while paused; forcing playback"
                            )
                        else:
                            logger.info(f"Playing: Bank {cur_bank}, Station {cur_station}")
                        sh(["radio-play", str(cur_bank), str(cur_station)])
                        playing_bank = cur_bank
                        playing_station = cur_station
                        # Reset watchdog for the new station
                        watchdog_stop_since = 0.0
                        watchdog_backoff = WATCHDOG_GRACE_SEC
                else:
                    logger.warning(f"Station does not exist: Bank {cur_bank}, Station {cur_station}")
            
            # Handle volume encoder with I2C error handling
            try:
                vol_pos = vol_enc.position
            except OSError as err:
                logger.warning(f"I2C error reading encoder: {err}")
                vol_pos = last_vol_pos
                time.sleep(I2C_ERR_BACKOFF)
            
            # Glitch filter: ignore large jumps
            if abs(vol_pos - last_vol_pos) > MAX_JUMP:
                logger.debug(f"Volume encoder glitch filtered: {vol_pos} → {last_vol_pos}")
                vol_pos = last_vol_pos
            
            # Handle volume change
            if vol_pos != last_vol_pos:
                delta = last_vol_pos - vol_pos
                last_vol_pos = vol_pos
                
                # Get current MPD volume
                status = mpd_conn.status()
                vol = last_volume
                try:
                    vol = int(status.get("volume", last_volume))
                except (TypeError, ValueError):
                    pass
                
                if muted:
                    # When muted, track volume changes but don't apply to MPD
                    last_volume = clamp(last_volume + delta * vstep, vmin, vmax)
                    logger.debug(f"Volume change while muted: {last_volume}")
                else:
                    vol = clamp(vol + delta * vstep, vmin, vmax)
                    last_volume = vol
                    mpd_conn.setvol(vol)
                    write_state(STATE_PATH, last_volume=vol)
                    logger.debug(f"Volume: {vol}")
            
            # Handle button press
            btn = ss.digital_read(SEESAW_BUTTON_PIN)
            if last_btn == 1 and btn == 0:  # Falling edge (button pressed)
                action = btn_cfg.get("volume_button", "noop")
                logger.info(f"Volume button pressed, action: {action}")
                
                if action == "play_pause":
                    mpd_conn.toggle()
                elif action == "mute_toggle":
                    if not muted:
                        muted = True
                        mpd_conn.setvol(0)
                        logger.info("Muted")
                    else:
                        muted = False
                        mpd_conn.setvol(last_volume)
                        logger.info(f"Unmuted, volume: {last_volume}")
            
            last_btn = btn

            # Handle physical play/pause switch (active LOW when OFF)
            play_switch_state = GPIO.input(PLAY_PAUSE_SWITCH_PIN)
            new_play_enabled = play_switch_state == GPIO.HIGH
            if new_play_enabled != play_enabled:
                play_enabled = new_play_enabled
                if play_enabled:
                    if stations_cache.station_exists(cur_bank, cur_station) and (
                        cur_bank != playing_bank or cur_station != playing_station
                    ):
                        logger.info(
                            f"Play switch ON: playing selected Bank {cur_bank}, Station {cur_station}"
                        )
                        sh(["radio-play", str(cur_bank), str(cur_station)])
                        playing_bank = cur_bank
                        playing_station = cur_station
                        watchdog_stop_since = 0.0
                        watchdog_backoff = WATCHDOG_GRACE_SEC
                    else:
                        logger.info("Play switch ON: resuming playback")
                        mpd_conn.play()
                else:
                    logger.info("Play switch OFF: pausing playback")
                    mpd_conn.pause()
            
            # ── Playback watchdog ─────────────────────────────────
            # Detect when a stream has stopped unexpectedly (TLS
            # error, server disconnect, MPD restart with empty
            # playlist) and automatically re-trigger playback.
            if play_enabled and now - watchdog_last_check >= WATCHDOG_CHECK_INTERVAL:
                watchdog_last_check = now
                stype = stations_cache.station_type(playing_bank, playing_station)
                if stype in _STREAM_TYPES:
                    try:
                        mpd_state = mpd_conn.status().get("state", "")
                    except Exception:
                        mpd_state = ""
                    if mpd_state == "stop":
                        if watchdog_stop_since == 0.0:
                            watchdog_stop_since = now
                            logger.info(
                                "Watchdog: stream stopped, waiting %.0fs before restart",
                                watchdog_backoff,
                            )
                        elif now - watchdog_stop_since >= watchdog_backoff:
                            logger.info(
                                "Watchdog: restarting Bank %d, Station %d "
                                "(stopped for %.1fs)",
                                playing_bank,
                                playing_station,
                                now - watchdog_stop_since,
                            )
                            sh(["radio-play", str(playing_bank), str(playing_station)])
                            watchdog_last_restart = now
                            watchdog_stop_since = 0.0
                            # Exponential backoff: double the grace period
                            # so a persistently broken stream doesn't hammer
                            watchdog_backoff = min(
                                watchdog_backoff * 2, WATCHDOG_BACKOFF_MAX
                            )
                    else:
                        # MPD is playing/paused — reset watchdog state
                        if watchdog_stop_since != 0.0:
                            logger.info("Watchdog: playback resumed, resetting")
                        watchdog_stop_since = 0.0
                        watchdog_backoff = WATCHDOG_GRACE_SEC

            # Sleep until next poll
            time.sleep(poll_interval)
        
        except OSError as e:
            # Transient I2C errors
            logger.error(f"I2C error in main loop: {e}")
            time.sleep(0.2)
        except KeyboardInterrupt:
            logger.info("Shutting down (KeyboardInterrupt)")
            GPIO.cleanup()
            break
        except Exception as e:
            logger.error(f"Unexpected error: {e}", exc_info=True)
            time.sleep(1.0)


if __name__ == "__main__":
    try:
        main()
    finally:
        GPIO.cleanup()
